<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>RPC WebSocket客户端（MD5加密）</title>
    <style>
        body {font-family: Arial, sans-serif; margin: 20px;}
        .container {max-width: 800px; margin: 0 auto;}
        .log-box {width: 100%; height: 300px; border: 1px solid #ccc; padding: 10px; overflow-y: auto; margin: 10px 0;}
        button {padding: 8px 16px; margin: 5px; cursor: pointer;}
        input {padding: 8px; margin: 5px; width: 200px;}
    </style>
    <!-- 引入crypto-js库（CDN方式，无需本地安装） -->
    <script src="https://cdn.bootcdn.net/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>
    <div class="container">
        <h2>RPC WebSocket客户端（MD5加密）</h2>

        <div>
            <label>服务端地址：</label>
            <input type="text" id="wsUrl" value="ws://127.0.0.1:8765">
            <button onclick="connect()">连接</button>
            <button onclick="disconnect()">断开</button>
        </div>

        <div>
            <label>分组：</label>
            <input type="text" id="groupName" value="encrypt_group">
            <label>接口：</label>
            <input type="text" id="interfaceName" value="md5_encrypt">
            <button onclick="registerInterface()">注册接口</button>
        </div>

        <div>
            <h4>日志：</h4>
            <div id="logBox" class="log-box"></div>
        </div>
    </div>

    <script>
        let ws = null;
        const logBox = document.getElementById('logBox');

        // 日志函数
        function log(msg) {
            logBox.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`;
            logBox.scrollTop = logBox.scrollHeight;
        }

        // ========== 极简MD5加密（基于crypto-js） ==========
        function md5Encrypt(str) {
            // 一行代码实现32位小写MD5加密，与Python标准md5完全一致
            return CryptoJS.MD5(str).toString(CryptoJS.enc.Hex);
        }

        // 连接服务端
        function connect() {
            const wsUrl = document.getElementById('wsUrl').value;
            if (ws && ws.readyState === WebSocket.OPEN) {
                log('已连接到服务端，无需重复连接');
                return;
            }

            try {
                ws = new WebSocket(wsUrl);
                ws.onopen = () => {
                    log(`成功连接到服务端: ${wsUrl}`);
                    // 心跳包（每30秒）
                    setInterval(() => ws.readyState === WebSocket.OPEN && ws.send(JSON.stringify({cmd: 'heartbeat'})), 30000);
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    log(`收到服务端消息: ${JSON.stringify(data)}`);
                    // 处理接口调用指令
                    if (data.cmd === 'invoke') handleInvoke(data);
                };

                ws.onclose = () => { log('与服务端的连接已关闭'); ws = null; };
                ws.onerror = (error) => { log(`连接出错: ${error}`); };
            } catch (e) {
                log(`连接失败: ${e.message}`);
            }
        }

        // 断开连接
        function disconnect() {
            ws ? (ws.close(), log('主动断开连接')) : log('未连接到服务端');
        }

        // 注册接口
        function registerInterface() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return log('请先连接到服务端');

            const group = document.getElementById('groupName').value.trim();
            const interfaceName = document.getElementById('interfaceName').value.trim();

            if (!group || !interfaceName) return log('分组名和接口名不能为空');

            const registerMsg = {cmd: 'register', group, interface: interfaceName};
            ws.send(JSON.stringify(registerMsg));
            log(`发送注册指令: ${JSON.stringify(registerMsg)}`);
        }

        // 处理接口调用
        function handleInvoke(data) {
            log(`收到调用指令: ${data.group}.${data.interface}，参数: ${JSON.stringify(data.params)}`);

            let result = {success: false, data: "", call_id: data.call_id};
            // 处理MD5加密接口
            if (data.group === "encrypt_group" && data.interface === "md5_encrypt2") {
                const content = data.params?.content;
                if (!content) {
                    result.error = "缺少待加密的content参数";
                } else {
                    const md5Result = md5Encrypt(content);
                    result.success = true;
                    result.data = {
                        original_content: content,
                        md5_content: md5Result,
                        encrypt_type: "MD5 (32位小写)"
                    };
                    log(`MD5加密成功: 原文=${content} → 密文=${md5Result}`);
                }
            } else {
                result.error = `不支持的接口: ${data.group}.${data.interface}`;
            }

            // 返回结果给服务端
            ws.send(JSON.stringify(result));
            log(`返回执行结果: ${JSON.stringify(result)}`);
        }
    </script>
</body>
</html>